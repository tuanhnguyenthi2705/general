#!/usr/bin/env bash
set -uo pipefail   # không dùng -e để không tự kill khi lỗi nhỏ
set +m             # tắt job control logs

# ====== MÀU SẮC ======
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; NC='\033[0m'
info(){ echo -e "${GREEN}[INFO]${NC} $*"; }
warn(){ echo -e "${YELLOW}[WARNING]${NC} $*"; }
err(){  echo -e "${RED}[ERROR]${NC} $*"; }

# ====== ĐƯỜNG DẪN ======
BLOCKASSIST_DIR="/root/blockassist"
DEST_DIR="$BLOCKASSIST_DIR/modal-login"
TOKEN_FILE="/home/$(logname)/gensyn/huggingface.token"
LOG_FILE="$BLOCKASSIST_DIR/LOG.log"
mkdir -p "$BLOCKASSIST_DIR" "$DEST_DIR"
touch "$LOG_FILE"

# ====== TRAP ======
cleanup(){ warn "Nhận tín hiệu dừng. Kết thúc vòng chạy."; exit 0; }
trap cleanup INT TERM
trap '' HUP SIGCHLD   # bỏ qua SSH treo & ẩn "Cleaning up processes..."

# ====== CHECK TOOL ======
command -v python >/dev/null 2>&1 || { err "Thiếu python"; exit 1; }
command -v pip >/dev/null 2>&1 || { err "Thiếu pip"; exit 1; }
command -v expect >/dev/null 2>&1 || { info "Cài đặt expect..."; apt-get update -y && apt-get install -y expect; }

# ====== TOKEN ======
[ -f "$TOKEN_FILE" ] || { err "Không tìm thấy $TOKEN_FILE"; exit 1; }
TOKENS="$(grep -vE '^\s*#|^\s*$' "$TOKEN_FILE" || true)"
NUM_TOKENS=$(printf "%s\n" "$TOKENS" | wc -l | awk '{print $1}')
[ "$NUM_TOKENS" -ge 1 ] || { err "Không có token hợp lệ"; exit 1; }
info "Tổng token hợp lệ: $NUM_TOKENS"

# ====== NHẬP KHOẢNG ======
START_ARG="${1:-}"; END_ARG="${2:-}"
validate_range(){ [[ "$1" =~ ^[0-9]+$ ]] && [[ "$2" =~ ^[0-9]+$ ]] && [ "$1" -ge 1 ] && [ "$2" -le 150 ]; }
if [ -n "$START_ARG" ] && [ -n "$END_ARG" ]; then
    START="$START_ARG"; END="$END_ARG"
elif [ -t 0 ]; then
    exec 3</dev/tty || true
    read -rp "Nhập số bắt đầu (1..150): " START <&3 || START=1
    read -rp "Nhập số kết thúc (1..150): " END <&3 || END=150
else
    err "Không ở chế độ tương tác. Dùng: $0 <START> <END>"; exit 1
fi
if ! validate_range "$START" "$END"; then err "Khoảng không hợp lệ"; exit 1; fi
[ "$END" -lt "$START" ] && { tmp="$START"; START="$END"; END="$tmp"; }
info "Khoảng chạy: $START..$END"

# ====== HÀM ======
get_token_by_index(){ local i="$1"; [ "$i" -ge 1 ] && [ "$i" -le "$NUM_TOKENS" ] && printf "%s\n" "$TOKENS" | sed -n "${i}p" || echo ""; }

copy_training_data(){
  local i="$1"
  local SRC="/home/$(logname)/gensyn/${i}/temp-data"
  local DST="$DEST_DIR/temp-data"
  [ -d "$SRC" ] || { err "Không thấy $SRC"; return 1; }
  rm -rf "$DST"; mkdir -p "$DST"
  cp -a "$SRC"/. "$DST"/
  info "Đã copy temp-data $i"
}

run_training(){
  local i="$1"; local token="$2"
  [ -n "$token" ] || { warn "Thiếu token cho i=$i"; return 1; }
  cd "$BLOCKASSIST_DIR"
  local EXPECT_SCRIPT; EXPECT_SCRIPT="$(mktemp)"
  cat > "$EXPECT_SCRIPT" <<'EOS'
#!/usr/bin/expect -f
set timeout -1
spawn python run.py
expect {
  -re "(?i)token"       { send "$env(HF_TOKEN)\r"; exp_continue }
  -re "(?i)huggingface" { send "$env(HF_TOKEN)\r"; exp_continue }
  eof
}
EOS
  chmod +x "$EXPECT_SCRIPT"
  HF_TOKEN="$token" setsid bash -lc '
    trap "" TERM INT
    {
      echo "=== $(date "+%F %T") | i='"$i"' ==="
      PUBLIC_IP=$(curl -s --max-time 6 -4 ifconfig.me || echo "unknown")
      echo "Public IP: $PUBLIC_IP"
      "'"$EXPECT_SCRIPT"'" 2>&1 | tee -a "'"$LOG_FILE"'" || true
      echo "=== Kết thúc i='"$i"' lúc $(date "+%F %T") ==="
    } >>"'"$LOG_FILE"'" 2>&1
  ' &
  wait $! 2>/dev/null || true
  rm -f "$EXPECT_SCRIPT"
  info "Hoàn tất i=$i"
}

process_once(){
  local s="${1:-1}"; local e="${2:-150}"
  for i in $(seq "$s" "$e"); do
    info "---- Xử lý i=$i ----"
    copy_training_data "$i" || { warn "Lỗi copy $i"; continue; }
    local token; token="$(get_token_by_index "$i")"
    [ -z "$token" ] && { warn "Không có token dòng $i"; continue; }
    run_training "$i" "$token" || warn "Lỗi training i=$i"
    local SLEEP_TIME=$((RANDOM % 21 + 20))
    echo "Sleep $SLEEP_TIME s" | tee -a "$LOG_FILE"; sleep "$SLEEP_TIME"
  done
}

# ====== VÒNG LẶP + DEBUG ======
info "Bắt đầu vòng xoay $START..$END (Ctrl+C để dừng)."
while true; do
  process_once "$START" "$END"
  ec=$?
  echo "[DEBUG] process_once exit=$ec at $(date '+%F %T')" | tee -a "$LOG_FILE"
  sleep 2
done
