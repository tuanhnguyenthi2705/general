#!/usr/bin/env bash
set -uo pipefail        # Không tự kill khi lệnh con lỗi
set +m                  # Tắt job-control messages (Stopped/Terminated)

# ===== Single-instance lock (tránh chạy trùng) =====
LOCK_FILE="/var/lock/blockassist.lock"
exec {lock_fd}<> "$LOCK_FILE" || exit 1
if ! flock -n "$lock_fd"; then
  echo "[WARN] Instance already running (lock $LOCK_FILE). Exit."
  exit 0
fi

# ===== LOG COLOR =====
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; NC='\033[0m'
info(){ echo -e "${GREEN}[INFO]${NC} $*"; }
warn(){ echo -e "${YELLOW}[WARNING]${NC} $*"; }
err(){  echo -e "${RED}[ERROR]${NC} $*"; }

# ===== PATHS =====
BLOCKASSIST_DIR="/root/blockassist"
DEST_DIR="$BLOCKASSIST_DIR/modal-login"
TOKEN_FILE="/home/$(logname)/gensyn/huggingface.token"
LOG_FILE="$BLOCKASSIST_DIR/LOG.log"

mkdir -p "$BLOCKASSIST_DIR" "$DEST_DIR"
touch "$LOG_FILE"

# ===== TRAPS =====
cleanup(){ warn "Nhận tín hiệu dừng. Kết thúc vòng chạy."; exit 0; }
trap cleanup INT TERM
trap '' HUP SIGCHLD        # Bỏ qua treo SSH & ẩn "Cleaning up processes..."

# ===== TOOL CHECK =====
command -v python >/dev/null 2>&1 || { err "Thiếu python"; exit 1; }
command -v pip    >/dev/null 2>&1 || { err "Thiếu pip"; exit 1; }
if ! command -v expect >/dev/null 2>&1; then
  info "Cài đặt expect..."
  apt-get update -y && apt-get install -y expect
fi

# Cài psutil/readchar nếu thiếu (không dùng cấu trúc lạ gây lỗi bash)
python - <<'PY' || true
try:
    import psutil
except Exception:
    import os; os.system("pip install -q psutil")
try:
    import readchar
except Exception:
    import os; os.system("pip install -q readchar")
PY

# ===== TOKENS =====
[ -f "$TOKEN_FILE" ] || { err "Không tìm thấy token: $TOKEN_FILE"; exit 1; }
TOKENS="$(grep -vE '^\s*#|^\s*$' "$TOKEN_FILE" || true)"
NUM_TOKENS=$(printf "%s\n" "$TOKENS" | wc -l | awk '{print $1}')
[ "$NUM_TOKENS" -ge 1 ] || { err "File token không có dòng hợp lệ."; exit 1; }
info "Tổng số token hợp lệ: $NUM_TOKENS"

# ===== RANGE INPUT =====
START_ARG="${1:-}"; END_ARG="${2:-}"
START=""; END=""

validate_range(){
  local s="$1" e="$2"
  [[ "$s" =~ ^[0-9]+$ ]] && [[ "$e" =~ ^[0-9]+$ ]] || return 1
  [ "$s" -ge 1 ] && [ "$e" -ge 1 ] && [ "$s" -le 150 ] && [ "$e" -le 150 ] || return 1
  return 0
}

if [ -n "$START_ARG" ] && [ -n "$END_ARG" ]; then
  if validate_range "$START_ARG" "$END_ARG"; then
    START="$START_ARG"; END="$END_ARG"
  else
    err "Tham số không hợp lệ. Dùng: $0 <START 1..150> <END 1..150>"; exit 1
  fi
else
  if [ -t 0 ]; then
    exec 3</dev/tty || true
    read -rp "Nhập số bắt đầu (1..150): " START <&3 || START=1
    read -rp "Nhập số kết thúc (1..150): " END <&3 || END=150
    if ! validate_range "${START:-}" "${END:-}"; then
      err "Khoảng nhập không hợp lệ. Vui lòng chạy lại và nhập 1..150."; exit 1
    fi
  else
    err "Không ở chế độ tương tác. Hãy chạy với tham số: $0 <START> <END> (vd: $0 11 20)"; exit 1
  fi
fi

if [ "$END" -lt "$START" ]; then
  warn "END < START, hoán đổi."
  tmp="$START"; START="$END"; END="$tmp"
fi
info "Khoảng chạy: $START .. $END (xoay vòng vô hạn)."

# ===== HELPERS =====
get_token_by_index(){
  local idx="$1"
  if [ "$idx" -ge 1 ] && [ "$idx" -le "$NUM_TOKENS" ]; then
    printf "%s\n" "$TOKENS" | sed -n "${idx}p"
  else
    echo ""
  fi
}

copy_training_data(){
  local i="$1"
  local SRC="/home/$(logname)/gensyn/${i}/temp-data"
  local DST="$DEST_DIR/temp-data"
  [ -d "$SRC" ] || { err "Không thấy: $SRC"; return 1; }
  rm -rf "$DST"; mkdir -p "$DST"
  cp -a "$SRC"/. "$DST"/
  info "Đã đồng bộ temp-data từ $SRC -> $DST"
}

run_training(){
  local i="$1"; local token="$2"
  [ -n "$token" ] || { warn "Thiếu token cho i=$i"; return 1; }
  cd "$BLOCKASSIST_DIR" || { err "Không cd tới $BLOCKASSIST_DIR"; return 1; }

  # expect tạm
  local EXPECT_SCRIPT; EXPECT_SCRIPT="$(mktemp)"
  cat > "$EXPECT_SCRIPT" <<'EOS'
#!/usr/bin/expect -f
set timeout -1
spawn python run.py
expect {
    -re "(?i)token"       { send "$env(HF_TOKEN)\r"; exp_continue }
    -re "(?i)huggingface" { send "$env(HF_TOKEN)\r"; exp_continue }
    eof
}
EOS
  chmod +x "$EXPECT_SCRIPT"

  # Tách session, chặn tín hiệu trong subshell; luôn ghi log
  HF_TOKEN="$token" setsid bash -lc '
    trap "" TERM INT
    {
      echo "=== $(date "+%F %T") | i='"$i"' ==="
      PUBLIC_IP=$(curl -s --max-time 6 -4 ifconfig.me || echo "unknown")
      echo "Public IP: $PUBLIC_IP"
      "'"$EXPECT_SCRIPT"'" 2>&1 | tee -a "'"$LOG_FILE"'" || true
      echo "=== Kết thúc i='"$i"' lúc $(date "+%F %T") ==="
    } >>"'"$LOG_FILE"'" 2>&1
  ' &
  wait $! 2>/dev/null || true

  rm -f "$EXPECT_SCRIPT"
  info "Hoàn tất i=$i"
}

process_once(){
  local s="${1:-1}"; local e="${2:-150}"
  for i in $(seq "$s" "$e"); do
    info "---------- XỬ LÝ i = $i ----------"
    copy_training_data "$i" || { warn "Lỗi copy data i=$i -> bỏ qua."; continue; }
    local token; token="$(get_token_by_index "$i")"
    if [ -z "$token" ]; then warn "Không có token ứng với i=$i (file token có $NUM_TOKENS dòng)."; continue; fi
    run_training "$i" "$token" || warn "Lỗi training i=$i"
    SLEEP_TIME=45
    echo "Sleep $SLEEP_TIME s" | tee -a "$LOG_FILE"; sleep "$SLEEP_TIME"
  done
}

# ===== LOOP + DEBUG =====
info "Bắt đầu vòng xoay trong khoảng $START..$END. Dừng bằng Ctrl+C."
while true; do
  process_once "$START" "$END"
  ec=$?
  echo "[DEBUG] process_once exit=$ec at $(date '+%F %T')" | tee -a "$LOG_FILE"
  sleep 2
done
#!/usr/bin/env bash
set -uo pipefail        # Không tự kill khi lệnh con lỗi
set +m                  # Tắt job-control messages (Stopped/Terminated)

# ===== Single-instance lock (tránh chạy trùng) =====
LOCK_FILE="/var/lock/blockassist.lock"
exec {lock_fd}<> "$LOCK_FILE" || exit 1
if ! flock -n "$lock_fd"; then
  echo "[WARN] Instance already running (lock $LOCK_FILE). Exit."
  exit 0
fi

# ===== LOG COLOR =====
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; NC='\033[0m'
info(){ echo -e "${GREEN}[INFO]${NC} $*"; }
warn(){ echo -e "${YELLOW}[WARNING]${NC} $*"; }
err(){  echo -e "${RED}[ERROR]${NC} $*"; }

# ===== PATHS =====
BLOCKASSIST_DIR="/root/blockassist"
DEST_DIR="$BLOCKASSIST_DIR/modal-login"
TOKEN_FILE="/home/$(logname)/gensyn/huggingface.token"
LOG_FILE="$BLOCKASSIST_DIR/LOG.log"

mkdir -p "$BLOCKASSIST_DIR" "$DEST_DIR"
touch "$LOG_FILE"

# ===== TRAPS =====
cleanup(){ warn "Nhận tín hiệu dừng. Kết thúc vòng chạy."; exit 0; }
trap cleanup INT TERM
trap '' HUP SIGCHLD        # Bỏ qua treo SSH & ẩn "Cleaning up processes..."

# ===== TOOL CHECK =====
command -v python >/dev/null 2>&1 || { err "Thiếu python"; exit 1; }
command -v pip    >/dev/null 2>&1 || { err "Thiếu pip"; exit 1; }
if ! command -v expect >/dev/null 2>&1; then
  info "Cài đặt expect..."
  apt-get update -y && apt-get install -y expect
fi

# Cài psutil/readchar nếu thiếu (không dùng cấu trúc lạ gây lỗi bash)
python - <<'PY' || true
try:
    import psutil
except Exception:
    import os; os.system("pip install -q psutil")
try:
    import readchar
except Exception:
    import os; os.system("pip install -q readchar")
PY

# ===== TOKENS =====
[ -f "$TOKEN_FILE" ] || { err "Không tìm thấy token: $TOKEN_FILE"; exit 1; }
TOKENS="$(grep -vE '^\s*#|^\s*$' "$TOKEN_FILE" || true)"
NUM_TOKENS=$(printf "%s\n" "$TOKENS" | wc -l | awk '{print $1}')
[ "$NUM_TOKENS" -ge 1 ] || { err "File token không có dòng hợp lệ."; exit 1; }
info "Tổng số token hợp lệ: $NUM_TOKENS"

# ===== RANGE INPUT =====
START_ARG="${1:-}"; END_ARG="${2:-}"
START=""; END=""

validate_range(){
  local s="$1" e="$2"
  [[ "$s" =~ ^[0-9]+$ ]] && [[ "$e" =~ ^[0-9]+$ ]] || return 1
  [ "$s" -ge 1 ] && [ "$e" -ge 1 ] && [ "$s" -le 150 ] && [ "$e" -le 150 ] || return 1
  return 0
}

if [ -n "$START_ARG" ] && [ -n "$END_ARG" ]; then
  if validate_range "$START_ARG" "$END_ARG"; then
    START="$START_ARG"; END="$END_ARG"
  else
    err "Tham số không hợp lệ. Dùng: $0 <START 1..150> <END 1..150>"; exit 1
  fi
else
  if [ -t 0 ]; then
    exec 3</dev/tty || true
    read -rp "Nhập số bắt đầu (1..150): " START <&3 || START=1
    read -rp "Nhập số kết thúc (1..150): " END <&3 || END=150
    if ! validate_range "${START:-}" "${END:-}"; then
      err "Khoảng nhập không hợp lệ. Vui lòng chạy lại và nhập 1..150."; exit 1
    fi
  else
    err "Không ở chế độ tương tác. Hãy chạy với tham số: $0 <START> <END> (vd: $0 11 20)"; exit 1
  fi
fi

if [ "$END" -lt "$START" ]; then
  warn "END < START, hoán đổi."
  tmp="$START"; START="$END"; END="$tmp"
fi
info "Khoảng chạy: $START .. $END (xoay vòng vô hạn)."

# ===== HELPERS =====
get_token_by_index(){
  local idx="$1"
  if [ "$idx" -ge 1 ] && [ "$idx" -le "$NUM_TOKENS" ]; then
    printf "%s\n" "$TOKENS" | sed -n "${idx}p"
  else
    echo ""
  fi
}

copy_training_data(){
  local i="$1"
  local SRC="/home/$(logname)/gensyn/${i}/temp-data"
  local DST="$DEST_DIR/temp-data"
  [ -d "$SRC" ] || { err "Không thấy: $SRC"; return 1; }
  rm -rf "$DST"; mkdir -p "$DST"
  cp -a "$SRC"/. "$DST"/
  info "Đã đồng bộ temp-data từ $SRC -> $DST"
}

run_training(){
  local i="$1"; local token="$2"
  [ -n "$token" ] || { warn "Thiếu token cho i=$i"; return 1; }
  cd "$BLOCKASSIST_DIR" || { err "Không cd tới $BLOCKASSIST_DIR"; return 1; }

  # expect tạm
  local EXPECT_SCRIPT; EXPECT_SCRIPT="$(mktemp)"
  cat > "$EXPECT_SCRIPT" <<'EOS'
#!/usr/bin/expect -f
set timeout -1
spawn python run.py
expect {
    -re "(?i)token"       { send "$env(HF_TOKEN)\r"; exp_continue }
    -re "(?i)huggingface" { send "$env(HF_TOKEN)\r"; exp_continue }
    eof
}
EOS
  chmod +x "$EXPECT_SCRIPT"

  # Tách session, chặn tín hiệu trong subshell; luôn ghi log
  HF_TOKEN="$token" setsid bash -lc '
    trap "" TERM INT
    {
      echo "=== $(date "+%F %T") | i='"$i"' ==="
      PUBLIC_IP=$(curl -s --max-time 6 -4 ifconfig.me || echo "unknown")
      echo "Public IP: $PUBLIC_IP"
      "'"$EXPECT_SCRIPT"'" 2>&1 | tee -a "'"$LOG_FILE"'" || true
      echo "=== Kết thúc i='"$i"' lúc $(date "+%F %T") ==="
    } >>"'"$LOG_FILE"'" 2>&1
  ' &
  wait $! 2>/dev/null || true

  rm -f "$EXPECT_SCRIPT"
  info "Hoàn tất i=$i"
}

process_once(){
  local s="${1:-1}"; local e="${2:-150}"
  for i in $(seq "$s" "$e"); do
    info "---------- XỬ LÝ i = $i ----------"
    copy_training_data "$i" || { warn "Lỗi copy data i=$i -> bỏ qua."; continue; }
    local token; token="$(get_token_by_index "$i")"
    if [ -z "$token" ]; then warn "Không có token ứng với i=$i (file token có $NUM_TOKENS dòng)."; continue; fi
    run_training "$i" "$token" || warn "Lỗi training i=$i"
    SLEEP_TIME=45
    echo "Sleep $SLEEP_TIME s" | tee -a "$LOG_FILE"; sleep "$SLEEP_TIME"
  done
}

# ===== LOOP + DEBUG =====
info "Bắt đầu vòng xoay trong khoảng $START..$END. Dừng bằng Ctrl+C."
while true; do
  process_once "$START" "$END"
  ec=$?
  echo "[DEBUG] process_once exit=$ec at $(date '+%F %T')" | tee -a "$LOG_FILE"
  sleep 2
done
