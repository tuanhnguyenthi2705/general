# ===================== SCRIPT: auto.run =====================
# Lưu ý: marker kết thúc here-doc PHẢI là 'AUTORUN_EOF' đứng một mình, không thụt lề, có newline sau đó.
cat > /home/xtr01/gensyn/run/auto.run <<'AUTORUN_EOF'
#!/bin/bash
set -euo pipefail

# --------- Config paths ----------
BASE_DIR="/home/xtr01/gensyn/run"    # /home/xtr01/gensyn/run/<idx>/
TARGET_DIR="/root/rl-swarm"          # rl-swarm repo
LOGIN_SUBDIR="modal-login"
BOOTNODES_FILE="$BASE_DIR/bootnodes.txt"
CONFIG_FILE="$TARGET_DIR/rgym_exp/config/rg-swarm.yaml"
APIDIR="$TARGET_DIR/$LOGIN_SUBDIR/temp-data"

log() { printf "%s - %s\n" "$(date '+%F %T')" "$*"; }

# --------- Detect max numeric folder 1..N ----------
MAX_FOLDER="$(find "$BASE_DIR" -maxdepth 1 -type d -regex '.*/[0-9]+' -printf '%f\n' | sort -n | tail -1 || true)"
MAX_FOLDER="${MAX_FOLDER:-1}"
if ! [[ "$MAX_FOLDER" =~ ^[0-9]+$ ]]; then MAX_FOLDER=1; fi
log "Phát hiện tối đa $MAX_FOLDER → cho phép chọn khoảng [START..END]"

# --------- Ensure jq exists (for JSON parsing) ----------
if ! command -v jq >/dev/null 2>&1; then
  apt-get update -y >/dev/null 2>&1 || true
  apt-get install -y jq >/dev/null 2>&1 || true
fi

# --------- Helpers: valid folder detection ----------
folder_has_required() {
  local idx="$1"
  [ -f "$BASE_DIR/$idx/swarm.pem" ] && [ -d "$BASE_DIR/$idx/temp-data" ]
}

next_valid_in_range() {
  # Tìm thư mục hợp lệ kể từ start (bao gồm start) trong khoảng [RANGE_START..RANGE_END]; vòng tròn trong khoảng
  local start="$1"
  local i="$start"
  local tries=0
  local span=$(( RANGE_END - RANGE_START + 1 ))
  while [ "$tries" -lt "$span" ]; do
    if folder_has_required "$i"; then
      echo "$i"
      return 0
    fi
    # tăng trong khoảng
    if [ "$i" -ge "$RANGE_END" ]; then i="$RANGE_START"; else i=$((i+1)); fi
    tries=$((tries+1))
  done
  echo ""
  return 1
}

# --------- Update bootnode inside YAML ----------
update_bootnode() {
  if [ ! -s "$BOOTNODES_FILE" ]; then
    log "CẢNH BÁO: $BOOTNODES_FILE không tồn tại/đang rỗng; giữ bootnode cũ"
    return 0
  fi
  local pick
  pick="$(grep -v '^[[:space:]]*$' "$BOOTNODES_FILE" | shuf -n 1 || true)"
  if [ -z "${pick:-}" ]; then
    log "CẢNH BÁO: Không lấy được bootnode; giữ bootnode cũ"
    return 0
  fi

  # Backup rotation (keep latest 5)
  cp -f "$CONFIG_FILE" "$CONFIG_FILE.backup.$(date +%Y%m%d%H%M%S)" || true
  ls -1t "$CONFIG_FILE".backup.* 2>/dev/null | tail -n +6 | xargs -r rm -f

  # Replace only the first "- '/ip4..." entry under initial_peers:
  awk -v BN="$pick" '
    BEGIN { replaced=0; in_peers=0 }
    /^[[:space:]]*initial_peers:[[:space:]]*$/ { in_peers=1; print; next }
    in_peers==1 && /^[[:space:]]*-[[:space:]]*'\''\/ip4/ && replaced==0 {
      sub(/-.*/, "- \x27" BN "\x27"); replaced=1; print; next
    }
    in_peers==1 && !/^[[:space:]]*-/ { in_peers=0; print; next }
    { print }
  ' "$CONFIG_FILE" > "$CONFIG_FILE.tmp"

  mv -f "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  RANDOM_BOOTNODE="$pick"
  export RANDOM_BOOTNODE
  log "Đã cập nhật bootnode: $RANDOM_BOOTNODE"
}

# --------- Copy credentials & restart rl-swarm ----------
copy_and_restart() {
  local idx="$1"
  local PEM_SOURCE="$BASE_DIR/$idx/swarm.pem"
  local TEMP_SOURCE="$BASE_DIR/$idx/temp-data"

  if [ ! -f "$PEM_SOURCE" ]; then
    log "LỖI: Không thấy $PEM_SOURCE"
    return 1
  fi
  if [ ! -d "$TEMP_SOURCE" ]; then
    log "LỖI: Không thấy $TEMP_SOURCE"
    return 1
  fi

  systemctl stop rl-swarm || true

  # Wait for rl-swarm to stop (max 30s)
  local count=0
  while systemctl is-active --quiet rl-swarm && [ $count -lt 30 ]; do
    sleep 1
    count=$((count+1))
  done

  # Kill any leftover Node processes
  pkill -f "yarn start" 2>/dev/null || true
  pkill -f "node.*modal-login" 2>/dev/null || true
  sleep 2

  # Copy pem & temp-data
  rm -f "$TARGET_DIR/swarm.pem"
  cp -f "$PEM_SOURCE" "$TARGET_DIR/"
  rm -rf "$TARGET_DIR/$LOGIN_SUBDIR/temp-data"
  mkdir -p "$TARGET_DIR/$LOGIN_SUBDIR"
  cp -r "$TEMP_SOURCE" "$TARGET_DIR/$LOGIN_SUBDIR/"

  # Update bootnode
  update_bootnode

  systemctl start rl-swarm

  # Accept userData.json (or userdata.json), wait up to 60s
  local USERDATA_C1="$APIDIR/userData.json"
  local USERDATA_C2="$APIDIR/userdata.json"
  local USERDATA=""
  local timeout=60
  local elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if [ -f "$USERDATA_C1" ]; then USERDATA="$USERDATA_C1"; break; fi
    if [ -f "$USERDATA_C2" ]; then USERDATA="$USERDATA_C2"; break; fi
    sleep 5
    elapsed=$((elapsed+5))
  done
  if [ -z "$USERDATA" ]; then
    log "CẢNH BÁO: Không thấy userData.json hay userdata.json sau $timeout giây"
    return 1
  fi

  # Wait until JSON non-empty & valid (max 60s)
  local json_wait=0
  while { [ ! -s "$USERDATA" ] || ! jq -e . "$USERDATA" >/dev/null 2>&1; } && [ $json_wait -lt 60 ]; do
    sleep 2
    json_wait=$((json_wait+2))
  done
  if ! jq -e . "$USERDATA" >/dev/null 2>&1; then
    log "LỖI: $USERDATA không phải JSON hợp lệ sau $json_wait giây"
    return 1
  fi

  # Robust orgId extraction:
  local ORG_ID
  ORG_ID="$(jq -r '(.. | objects | .orgId? // empty) | select(type=="string")' "$USERDATA" 2>/dev/null | head -n1 || true)"
  if [ -z "${ORG_ID:-}" ]; then
    ORG_ID="$(jq -r 'keys[0] // empty' "$USERDATA" 2>/dev/null || true)"
  fi
  if [ -z "${ORG_ID:-}" ]; then
    log "LỖI: Không tìm thấy orgId/organizationId trong $USERDATA. Dump scalar keys:"
    jq -r 'paths(scalars) as $p | [($p|map(tostring)|join(".")), (getpath($p)|tostring)] | @tsv' "$USERDATA" 2>/dev/null | sed 's/^/  • /'
    return 1
  fi
  log "Đọc ORG_ID = $ORG_ID"

  # ---------- Kiểm tra kích hoạt API + fallback userApiKey.json ----------
  local ok=0
  local RESP STATUS_LOWER

  # ƯU TIÊN 1: API JSON/text
  RESP="$(curl -s "http://localhost:3000/api/get-api-key-status?orgId=$ORG_ID" || echo "")"
  if echo "$RESP" | jq -e . >/dev/null 2>&1; then
    STATUS_LOWER="$(echo "$RESP" | jq -r '.status // empty' 2>/dev/null | tr "[:upper:]" "[:lower:]")"
    if [ "$STATUS_LOWER" = "activated" ]; then
      log "API trả trạng thái activated"
      ok=1
    fi
  else
    [ "$(echo "$RESP" | tr '[:upper:]' '[:lower:]')" = "activated" ] && { log "API trả activated (text)"; ok=1; }
  fi

  # ƯU TIÊN 2: Fallback userApiKey.json
  if [ $ok -eq 0 ]; then
    local APIKEY1="$APIDIR/userApiKey.json"
    local APIKEY2="$APIDIR/apikey.json"
    local APIKEY=""
    [ -f "$APIKEY1" ] && APIKEY="$APIKEY1"
    [ -z "$APIKEY" ] && [ -f "$APIKEY2" ] && APIKEY="$APIKEY2"

    if [ -n "$APIKEY" ] && jq -e . "$APIKEY" >/div/null 2>&1; then
      local KEY_OK=1
      jq -e --arg O "$ORG_ID" '
        ( .[$O][0].activated == true )
        or ( ( .[$O][0].publicKey // "" ) != "" and ( .[$O][0].privateKey // "" ) != "" )
      ' "$APIKEY" >/dev/null 2>&1 || KEY_OK=0

      if [ $KEY_OK -eq 1 ]; then
        log "userApiKey.json xác nhận ACTIVATED → bỏ qua chờ API"
        ok=1
      else
        log "userApiKey.json tồn tại nhưng chưa đủ điều kiện coi là ACTIVATED"
      fi
    else
      log "Không tìm thấy userApiKey.json hợp lệ để fallback"
    fi
  fi

  # Nếu vẫn chưa ok → poll API tối đa 5 phút
  if [ $ok -eq 0 ]; then
    local api_timeout=300
    local api_elapsed=0
    while [ $api_elapsed -lt $api_timeout ]; do
      RESP="$(curl -s "http://localhost:3000/api/get-api-key-status?orgId=$ORG_ID" || echo "")"
      if echo "$RESP" | jq -e . >/dev/null 2>&1; then
        STATUS_LOWER="$(echo "$RESP" | jq -r '.status // empty' 2>/dev/null | tr "[:upper:]" "[:lower:]")"
        if [ "$STATUS_LOWER" = "activated" ]; then
          log "API key đã kích hoạt (poll)"
          ok=1
          break
        fi
      else
        [ "$(echo "$RESP" | tr '[:upper:]' '[:lower:]')" = "activated" ] && { log "API key đã kích hoạt (poll: text)"; ok=1; break; }
      fi
      sleep 5
      api_elapsed=$((api_elapsed+5))
    done
    if [ $ok -eq 0 ]; then
      log "CẢNH BÁO: Không xác nhận được ACTIVATED (API & file key đều chưa hợp lệ theo tiêu chí)"
    fi
  fi
}

# --------- Input with 5s timeout (START & END) ----------
read_num_with_timeout() {
  local prompt="$1" default="$2"
  local val=""
  echo -n "$prompt (mặc định sau 5s = $default): "
  if read -r -t 5 val; then :; else val="$default"; echo "$val"; fi
  # chỉ lấy số
  if ! [[ "$val" =~ ^[0-9]+$ ]]; then val="$default"; fi
  echo "$val"
}

# ======== Read range [RANGE_START..RANGE_END] ========
DEFAULT_START=1
DEFAULT_END="$MAX_FOLDER"

IN_START="$(read_num_with_timeout "Nhập thư mục BẮT ĐẦU [1..$MAX_FOLDER]" "$DEFAULT_START")"
IN_END="$(read_num_with_timeout "Nhập thư mục KẾT THÚC [1..$MAX_FOLDER]" "$DEFAULT_END")"

# clamp & normalize
[ "$IN_START" -lt 1 ] && IN_START=1
[ "$IN_START" -gt "$MAX_FOLDER" ] && IN_START="$MAX_FOLDER"
[ "$IN_END" -lt 1 ] && IN_END=1
[ "$IN_END" -gt "$MAX_FOLDER" ] && IN_END="$MAX_FOLDER"
if [ "$IN_START" -gt "$IN_END" ]; then
  t="$IN_START"; IN_START="$IN_END"; IN_END="$t"
fi
RANGE_START="$IN_START"
RANGE_END="$IN_END"
log "Khoảng chạy: [$RANGE_START..$RANGE_END]"

# ======== Start on first valid in range ========
VALID_START="$(next_valid_in_range "$RANGE_START" || true)"
if [ -z "${VALID_START:-}" ]; then
  log "KHÔNG tìm được thư mục hợp lệ trong [$RANGE_START..$RANGE_END] — kiểm tra lại dữ liệu!"
  VALID_START="$RANGE_START"   # vẫn chạy để sinh log
fi

log "Khởi động với folder $VALID_START"
copy_and_restart "$VALID_START" || true
CURRENT_INDEX=$(( (VALID_START < RANGE_END) ? (VALID_START+1) : RANGE_START ))
TIMEOUT_SECONDS=600

# Mốc thời gian để đảm bảo 'Joining round' chỉ tính cho THƯ MỤC ĐANG CHẠY
CURRENT_STARTED_AT="$(date +%s)"
last_detect_time="$CURRENT_STARTED_AT"

# ======== Main loop ========
while true; do
  now="$(date +%s)"
  # Chỉ xét log sau khi folder hiện tại thực sự bắt đầu, và trong 30s gần nhất
  SINCE_TS=$(( CURRENT_STARTED_AT > (now-30) ? CURRENT_STARTED_AT : (now-30) ))
  LOG_RECENT="$(journalctl -u rl-swarm --since "@$SINCE_TS" -o cat 2>/dev/null || true)"

  rotate_within_range() {
    # tìm ứng viên hợp lệ trong khoảng
    local cand
    cand="$(next_valid_in_range "$CURRENT_INDEX" || true)"
    if [ -z "${cand:-}" ]; then
      cand="$CURRENT_INDEX"
      log "CẢNH BÁO: không tìm được thư mục hợp lệ trong khoảng; thử chạy tạm $cand"
    fi
    log "Chuyển folder $cand - ${RANDOM_BOOTNODE:-unknown}"
    copy_and_restart "$cand" || true
    # cập nhật con trỏ trong khoảng
    if [ "$cand" -ge "$RANGE_END" ]; then CURRENT_INDEX="$RANGE_START"; else CURRENT_INDEX=$((cand+1)); fi
    CURRENT_STARTED_AT="$(date +%s)"
    last_detect_time="$CURRENT_STARTED_AT"
  }

  if echo "$LOG_RECENT" | grep -q "Joining round"; then
    # chỉ xoay khi thật sự có 'Joining round' SAU khi start folder hiện tại
    rotate_within_range
  else
    if [ $((now - last_detect_time)) -ge $TIMEOUT_SECONDS ]; then
      log "TIMEOUT $TIMEOUT_SECONDS giây"
      rotate_within_range
    fi
  fi

  sleep 20
done
AUTORUN_EOF

# Ensure executable
chmod +x /home/xtr01/gensyn/run/auto.run
