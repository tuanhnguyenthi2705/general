#!/bin/bash
set -euo pipefail
trap 'echo "[ERROR] Failed at line $LINENO"; exit 1' ERR

# ========================= Detect USER_HOME safely =========================
LOGNAME=$(logname 2>/dev/null || true)
[ -z "${LOGNAME:-}" ] && LOGNAME="${SUDO_USER:-root}"
if [ "$LOGNAME" = "root" ]; then
  USER_HOME="/root"
else
  USER_HOME="/home/$LOGNAME"
fi

# ========================= Data dir =========================
mkdir -p "/home/xtr01/gensyn/run"  # thống nhất dùng /root để tránh lệch quyền/đường dẫn
BASE_RUN="/home/xtr01/gensyn/run"

# ===================== SERVICE: rl-swarm =====================
cat << 'EOF' > /etc/systemd/system/rl-swarm.service
[Unit]
Description=RL Swarm Service
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
WorkingDirectory=/root/rl-swarm
# Đổi ./run_first.sh thành script phù hợp nếu bạn muốn
ExecStart=/bin/bash -lc 'source /root/rl-swarm/.venv/bin/activate && ./run_first.sh'
Restart=always
RestartSec=5
User=root
Environment=PYTHONUNBUFFERED=1
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF

# ===================== SERVICE: rl-swarm2 =====================
cat << 'EOF' > /etc/systemd/system/rl-swarm2.service
[Unit]
Description=Auto Run Gensyn Script (folder cycler)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/home/xtr01/gensyn/run/auto.run
Restart=always
RestartSec=10
Environment=LOGNAME=root
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF

# ===================== SCRIPT: auto.run =====================
# Lưu ý: marker kết thúc here-doc PHẢI là 'AUTORUN_EOF' đứng một mình, không thụt lề, có newline sau đó.
cat > /home/xtr01/gensyn/run/auto.run <<'AUTORUN_EOF'
#!/bin/bash
set -euo pipefail

# --------- Config paths ----------
BASE_DIR="/home/xtr01/gensyn/run"          # source: /home/xtr01/gensyn/run/<idx>/
TARGET_DIR="/root/rl-swarm"          # rl-swarm repo
LOGIN_SUBDIR="modal-login"
BOOTNODES_FILE="$BASE_DIR/bootnodes.txt"
CONFIG_FILE="$TARGET_DIR/rgym_exp/config/rg-swarm.yaml"
APIDIR="$TARGET_DIR/$LOGIN_SUBDIR/temp-data"

log() { printf "%s - %s\n" "$(date '+%F %T')" "$*"; }

# --------- Detect max numeric folder 1..N ----------
MAX_FOLDER="$(find "$BASE_DIR" -maxdepth 1 -type d -regex '.*/[0-9]+' -printf '%f\n' | sort -n | tail -1 || true)"
MAX_FOLDER="${MAX_FOLDER:-1}"
log "Phát hiện $MAX_FOLDER folder, sẽ lặp 1..$MAX_FOLDER"

# --------- Ensure jq exists (for JSON parsing) ----------
if ! command -v jq >/dev/null 2>&1; then
  apt-get update -y >/dev/null 2>&1 || true
  apt-get install -y jq >/dev/null 2>&1 || true
fi

# --------- Update bootnode inside YAML ----------
update_bootnode() {
  if [ ! -s "$BOOTNODES_FILE" ]; then
    log "CẢNH BÁO: $BOOTNODES_FILE không tồn tại/đang rỗng; giữ bootnode cũ"
    return 0
  fi

  local pick
  pick="$(grep -v '^[[:space:]]*$' "$BOOTNODES_FILE" | shuf -n 1 || true)"
  if [ -z "${pick:-}" ]; then
    log "CẢNH BÁO: Không lấy được bootnode; giữ bootnode cũ"
    return 0
  fi

  # Backup rotation (keep latest 5)
  cp -f "$CONFIG_FILE" "$CONFIG_FILE.backup.$(date +%Y%m%d%H%M%S)" || true
  ls -1t "$CONFIG_FILE".backup.* 2>/dev/null | tail -n +6 | xargs -r rm -f

  # Replace only the first "- '/ip4..." entry under initial_peers:
  awk -v BN="$pick" '
    BEGIN { replaced=0; in_peers=0 }
    /^[[:space:]]*initial_peers:[[:space:]]*$/ { in_peers=1; print; next }
    in_peers==1 && /^[[:space:]]*-[[:space:]]*'\''\/ip4/ && replaced==0 {
      sub(/-.*/, "- \x27" BN "\x27"); replaced=1; print; next
    }
    in_peers==1 && !/^[[:space:]]*-/ { in_peers=0; print; next }
    { print }
  ' "$CONFIG_FILE" > "$CONFIG_FILE.tmp"

  mv -f "$CONFIG_FILE.tmp" "$CONFIG_FILE"
  RANDOM_BOOTNODE="$pick"
  export RANDOM_BOOTNODE
  log "Đã cập nhật bootnode: $RANDOM_BOOTNODE"
}

# --------- Copy credentials & restart rl-swarm ----------
copy_and_restart() {
  local idx="$1"
  local PEM_SOURCE="$BASE_DIR/$idx/swarm.pem"
  local TEMP_SOURCE="$BASE_DIR/$idx/temp-data"

  if [ ! -f "$PEM_SOURCE" ]; then
    log "LỖI: Không thấy $PEM_SOURCE"
    return 1
  fi
  if [ ! -d "$TEMP_SOURCE" ]; then
    log "LỖI: Không thấy $TEMP_SOURCE"
    return 1
  fi

  systemctl stop rl-swarm || true

  # Wait for rl-swarm to stop (max 30s)
  local count=0
  while systemctl is-active --quiet rl-swarm && [ $count -lt 30 ]; do
    sleep 1
    count=$((count+1))
  done

  # Kill any leftover Node processes
  pkill -f "yarn start" 2>/dev/null || true
  pkill -f "node.*modal-login" 2>/dev/null || true
  sleep 2

  # Copy pem & temp-data
  rm -f "$TARGET_DIR/swarm.pem"
  cp -f "$PEM_SOURCE" "$TARGET_DIR/"
  rm -rf "$TARGET_DIR/$LOGIN_SUBDIR/temp-data"
  mkdir -p "$TARGET_DIR/$LOGIN_SUBDIR"
  cp -r "$TEMP_SOURCE" "$TARGET_DIR/$LOGIN_SUBDIR/"

  # Update bootnode
  update_bootnode

  systemctl start rl-swarm

  # Accept userData.json (or userdata.json), wait up to 60s
  local USERDATA_C1="$APIDIR/userData.json"
  local USERDATA_C2="$APIDIR/userdata.json"
  local USERDATA=""
  local timeout=60
  local elapsed=0
  while [ $elapsed -lt $timeout ]; do
    if [ -f "$USERDATA_C1" ]; then USERDATA="$USERDATA_C1"; break; fi
    if [ -f "$USERDATA_C2" ]; then USERDATA="$USERDATA_C2"; break; fi
    sleep 5
    elapsed=$((elapsed+5))
  done
  if [ -z "$USERDATA" ]; then
    log "CẢNH BÁO: Không thấy userData.json hay userdata.json sau $timeout giây"
    return 1
  fi

  # Wait until JSON non-empty & valid (max 60s)
  local json_wait=0
  while { [ ! -s "$USERDATA" ] || ! jq -e . "$USERDATA" >/dev/null 2>&1; } && [ $json_wait -lt 60 ]; do
    sleep 2
    json_wait=$((json_wait+2))
  done
  if ! jq -e . "$USERDATA" >/dev/null 2>&1; then
    log "LỖI: $USERDATA không phải JSON hợp lệ sau $json_wait giây"
    return 1
  fi

  # Robust orgId extraction:
  # 1) any .orgId at any depth
  # 2) fallback: first top-level key (matches common structure)
  local ORG_ID
  ORG_ID="$(jq -r '(.. | objects | .orgId? // empty) | select(type=="string")' "$USERDATA" 2>/dev/null | head -n1 || true)"
  if [ -z "${ORG_ID:-}" ]; then
    ORG_ID="$(jq -r 'keys[0] // empty' "$USERDATA" 2>/dev/null || true)"
  fi
  if [ -z "${ORG_ID:-}" ]; then
    log "LỖI: Không tìm thấy orgId/organizationId trong $USERDATA. Dump scalar keys:"
    jq -r 'paths(scalars) as $p | [($p|map(tostring)|join(".")), (getpath($p)|tostring)] | @tsv' "$USERDATA" 2>/dev/null | sed 's/^/  • /'
    return 1
  fi
  log "Đọc ORG_ID = $ORG_ID"

  # ---------- Kiểm tra kích hoạt API + fallback userApiKey.json ----------
  local ok=0
  local RESP STATUS_LOWER

  # ƯU TIÊN 1: API JSON/text
  RESP="$(curl -s "http://localhost:3000/api/get-api-key-status?orgId=$ORG_ID" || echo "")"
  if echo "$RESP" | jq -e . >/dev/null 2>&1; then
    STATUS_LOWER="$(echo "$RESP" | jq -r '.status // empty' 2>/dev/null | tr "[:upper:]" "[:lower:]")"
    if [ "$STATUS_LOWER" = "activated" ]; then
      log "API trả trạng thái activated"
      ok=1
    fi
  else
    [ "$(echo "$RESP" | tr '[:upper:]' '[:lower:]')" = "activated" ] && { log "API trả activated (text)"; ok=1; }
  fi

  # ƯU TIÊN 2: Fallback userApiKey.json (đúng schema thực tế)
  if [ $ok -eq 0 ]; then
    local APIKEY1="$APIDIR/userApiKey.json"
    local APIKEY2="$APIDIR/apikey.json"   # tương thích cũ
    local APIKEY=""
    [ -f "$APIKEY1" ] && APIKEY="$APIKEY1"
    [ -z "$APIKEY" ] && [ -f "$APIKEY2" ] && APIKEY="$APIKEY2"

    if [ -n "$APIKEY" ] && jq -e . "$APIKEY" >/dev/null 2>&1; then
      # Điều kiện coi là activated:
      #   a) .[ORG_ID][0].activated == true  (ƯU TIÊN)
      #   b) hoặc có cặp publicKey/privateKey không rỗng
      local KEY_OK=1
      jq -e --arg O "$ORG_ID" '
        ( .[$O][0].activated == true )
        or ( ( .[$O][0].publicKey // "" ) != "" and ( .[$O][0].privateKey // "" ) != "" )
      ' "$APIKEY" >/dev/null 2>&1 || KEY_OK=0

      if [ $KEY_OK -eq 1 ]; then
        log "userApiKey.json xác nhận ACTIVATED → bỏ qua chờ API"
        ok=1
      else
        log "userApiKey.json tồn tại nhưng chưa đủ điều kiện coi là ACTIVATED"
      fi
    else
      log "Không tìm thấy userApiKey.json hợp lệ để fallback"
    fi
  fi

  # Nếu vẫn chưa ok → poll API tối đa 5 phút như cũ
  if [ $ok -eq 0 ]; then
    local api_timeout=300
    local api_elapsed=0
    while [ $api_elapsed -lt $api_timeout ]; do
      RESP="$(curl -s "http://localhost:3000/api/get-api-key-status?orgId=$ORG_ID" || echo "")"
      if echo "$RESP" | jq -e . >/dev/null 2>&1; then
        STATUS_LOWER="$(echo "$RESP" | jq -r '.status // empty' 2>/dev/null | tr "[:upper:]" "[:lower:]")"
        if [ "$STATUS_LOWER" = "activated" ]; then
          log "API key đã kích hoạt (poll)"
          ok=1
          break
        fi
      else
        [ "$(echo "$RESP" | tr '[:upper:]' '[:lower:]')" = "activated" ] && { log "API key đã kích hoạt (poll: text)"; ok=1; break; }
      fi
      sleep 5
      api_elapsed=$((api_elapsed+5))
    done
    if [ $ok -eq 0 ]; then
      log "CẢNH BÁO: Không xác nhận được ACTIVATED (API & file key đều chưa hợp lệ theo tiêu chí)"
    fi
  fi
}

# --------- First run with folder 1 ----------
log "Khởi động với folder 1"
copy_and_restart 1 || true

# --------- Main loop: watch logs & rotate ----------
CURRENT_INDEX=2
TIMEOUT_SECONDS=600
last_detect_time="$(date +%s)"

while true; do
  LOG_LAST_30S="$(journalctl -u rl-swarm --since "30 seconds ago" -o cat 2>/dev/null || true)"
  now="$(date +%s)"

  if echo "$LOG_LAST_30S" | grep -q "Already finished round"; then
    last_detect_time="$now"
    if [ "$CURRENT_INDEX" -gt "$MAX_FOLDER" ]; then
      CURRENT_INDEX=1
    fi
    log "Phát hiện Already finished round → chuyển folder $CURRENT_INDEX - ${RANDOM_BOOTNODE:-unknown}"
    copy_and_restart "$CURRENT_INDEX" || true
    CURRENT_INDEX=$((CURRENT_INDEX+1))
  else
    if [ $((now - last_detect_time)) -ge $TIMEOUT_SECONDS ]; then
      if [ "$CURRENT_INDEX" -gt "$MAX_FOLDER" ]; then
        CURRENT_INDEX=1
      fi
      log "TIMEOUT → chuyển folder $CURRENT_INDEX - ${RANDOM_BOOTNODE:-unknown}"
      copy_and_restart "$CURRENT_INDEX" || true
      CURRENT_INDEX=$((CURRENT_INDEX+1))
      last_detect_time="$now"
    fi
  fi

  sleep 20
done
AUTORUN_EOF

# Ensure executable
chmod +x /home/xtr01/gensyn/run/auto.run

# ===================== systemd reload =====================
systemctl daemon-reload

# ===================== Cron restart rl-swarm2 (every ~3h) =====================
CRON_CMD="0 2,5,8,11,14,17,20,23 * * * systemctl restart rl-swarm2"
CRON_COMMENT="# Auto restart rl-swarm2 every 3 hours"
CURRENT_CRON="$(crontab -l 2>/dev/null || true)"
if echo "$CURRENT_CRON" | grep -qF "systemctl restart rl-swarm2"; then
  UPDATED_CRON="$(echo "$CURRENT_CRON" | grep -vF "systemctl restart rl-swarm2" | grep -vF "Auto restart rl-swarm2")"
  if [ -z "$UPDATED_CRON" ]; then
    (echo "$CRON_COMMENT"; echo "$CRON_CMD") | crontab -
  else
    (echo "$UPDATED_CRON"; echo ""; echo "$CRON_COMMENT"; echo "$CRON_CMD") | crontab -
  fi
else
  if [ -z "$CURRENT_CRON" ]; then
    (echo "$CRON_COMMENT"; echo "$CRON_CMD") | crontab -
  else
    (echo "$CURRENT_CRON"; echo ""; echo "$CRON_COMMENT"; echo "$CRON_CMD") | crontab -
  fi
fi

# ===================== Install base packages =====================
echo "BAT DAU CAI DAT CAC PACKAGE CAN THIET"
PACKAGES="screen curl iptables build-essential git wget lz4 jq make gcc nano automake autoconf tmux htop nvme-cli libgbm1 pkg-config libssl-dev libleveldb-dev tar clang bsdmainutils ncdu unzip python3 python3-pip python3-venv ca-certificates"
MISSING=""
for pkg in $PACKAGES; do
  dpkg -l | grep -q "^ii  $pkg " || MISSING="$MISSING $pkg"
done
if [ -n "$MISSING" ]; then
  apt-get update
  apt-get install -y $MISSING
fi

# ===================== Node.js & Yarn via Corepack =====================
if command -v node >/dev/null 2>&1; then
  NODE_MAJOR="$(node -v | cut -d'.' -f1 | sed 's/v//')"
  if [ "$NODE_MAJOR" -lt 22 ]; then
    curl -fsSL https://deb.nodesource.com/setup_22.x | bash -
    apt-get install -y nodejs
  fi
else
  curl -fsSL https://deb.nodesource.com/setup_22.x | bash -
  apt-get install -y nodejs
fi

corepack enable
corepack prepare yarn@4 --activate
yarn -v || { echo "Yarn chưa sẵn sàng"; exit 1; }

# ===================== rl-swarm clone/sync & venv =====================
RL_SWARM_DIR="/root/rl-swarm"
if [ ! -d "$RL_SWARM_DIR" ]; then
  cd /root
  git clone https://github.com/hiepntnaa/rl-swarm/
fi

cd "$RL_SWARM_DIR"
if [ ! -d ".venv" ]; then
  python3 -m venv .venv
fi

set +e
source .venv/bin/activate 2>/dev/null
pip install -U pip >/dev/null 2>&1
[ -f requirements.txt ] && pip install -r requirements.txt || true
deactivate 2>/dev/null || true
set -e

# ===================== Bootnodes & sync code =====================
wget -q -O /home/xtr01/gensyn/run/bootnodes.txt https://raw.githubusercontent.com/thanhminguyen/general/refs/heads/main/bootnodes.txt || true
cd "$RL_SWARM_DIR" && git fetch origin && git reset --hard origin/main

# ===================== Final hints =====================
echo
echo -e "\e[92mĐể chạy tay lần đầu: cd /root/rl-swarm && . .venv/bin/activate && ./run_first.sh\e[0m"
echo
echo -e "\e[92mSau khi node bắt đầu training → bật dịch vụ:\e[0m"
echo -e "\e[92msystemctl enable rl-swarm rl-swarm2 && systemctl restart rl-swarm2\e[0m"
echo
